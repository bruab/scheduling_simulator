Exercise #1:

1) Results with -O0

time 		order
--------- 	-----
21.000000	ikj
22.000000	kij
34.000000	jik
40.000000	ijk
40.000000	jki
41.000000	kji

(see OUTPUT/ex1.0.output for all runs)

2) Consider three 4x4 matrices for illustration without bending the brain too much. Because each 2d matrix is stored in a 1d array, it is possible to access each element of the array in sequence. For example, moving from A[0][3] to A[1][0] is only moving one memory block forward. Moving this way, versus jumping around, is less likely to lead to cache misses. The top-performing ordering, ikj, leads to accessing the the C[][] matrix in exactly this way. Other orderings involve jumping around willy-nilly (e.g. from A[0][3] to A[3][0]), resulting in more misses.

3) Results with -Ofast:

time 		order
--------- 	-----
3.000000	ikj
3.000000	kij
10.000000	jik
15.000000	ijk
16.000000	kji
27.000000	jki

The code is faster than with -O0, of course, but there is a great deal of variation between the loop orderings -- an order of magnitude, in fact. Furthermore, the most obvious ordering ('ijk') is five times slower than the optimal ordering ('ikj'). Reasoning about loop performance might pay off if one is skilled at such reasoning; for my part, I think the experimental method is more reliable.

##########################################3333

Exercise #2

1) Exercise 2 runs in 4 seconds when compiled with -Ofast, and 14 seconds when compiled with -O0.

2) Hand-optimization is painful and error-fraught. I do not recommend it. It resulted in a best-case executable which is slower than the fastest version of Exercise 1. The -O0 executable is faster than its counterpart from the previous exercise, but the improvement gained from the hand optimization is negligible compared to what one gets from simply typing -Ofast.


##########################################3333

Exercise #3

1) Compiled with -O0:

time 		order
--------- 	-----
22.000000	ikj
22.000000	kij
23.000000	jki
23.000000	kji
25.000000	ijk
25.000000	jik

2) The results are much more consistent, but not any better than those obtained naively in Exercise 1. Blocking by hand might be useful if it were infeasible to reorder the for loops and experimentally determine the most efficient ordering. Otherwise I suppose I would not bother.

3) Compiled with -Ofast:

time 		order
--------- 	-----
3.000000	ikj
4.000000	kij
5.000000	ijk
5.000000	jik
5.000000	kji
6.000000	jki

Once again, the results are no faster, but they are much more consistent. I suppose if you block, your loop ordering doesn't matter. If you get the right loop ordering, blocking is not worth it.


